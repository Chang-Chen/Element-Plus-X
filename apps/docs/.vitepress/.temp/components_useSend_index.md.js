import { resolveComponent, useSSRContext } from "vue";
import { ssrRenderAttrs, ssrRenderComponent } from "vue/server-renderer";
import { _ as _export_sfc } from "./plugin-vue_export-helper.1tPrXgE0.js";
const __pageData = JSON.parse('{"title":"useSend & XRequest 🌳","description":"","frontmatter":{},"headers":[],"relativePath":"components/useSend/index.md","filePath":"components/useSend/index.md","lastUpdated":1745920435000}');
const _sfc_main = { name: "components/useSend/index.md" };
function _sfc_ssrRender(_ctx, _push, _parent, _attrs, $props, $setup, $data, $options) {
  const _component_demo = resolveComponent("demo");
  _push(`<div${ssrRenderAttrs(_attrs)}><h1 id="usesend-xrequest-🌳" tabindex="-1">useSend &amp; XRequest 🌳 <a class="header-anchor" href="#usesend-xrequest-🌳" aria-label="Permalink to &quot;useSend &amp; XRequest 🌳&quot;">​</a></h1><h2 id="背景介绍" tabindex="-1">背景介绍 <a class="header-anchor" href="#背景介绍" aria-label="Permalink to &quot;背景介绍&quot;">​</a></h2><p>基于 <code>ant-design-x</code> 的 <code>XRequest</code>，<code>XStream</code>，我们进行了深入的学习和讨论。</p><p>在复刻 <code>XStream</code> 后，针对更通用的 <strong>控制请求数据</strong> 和 <strong>中断请求</strong> 的场景，我们将 <code>ant-design-x</code> 的 <code>XRequest</code> 进行了重构，将其拆分成 <strong><code>前端终止场景</code></strong> 和 <strong><code>请求终止场景</code></strong></p><p>两种场景 分别对应</p><ul><li>hooks <code>useSend</code> -- 前端终止场景</li><li>工具类 <code>XRequest</code> -- 请求终止场景</li></ul><p><strong>🍒 两者可以单独拆开使用，组合使用可实现 <code>useXStream</code>，下面是他们的使用示例</strong></p><h2 id="代码演示" tabindex="-1">代码演示 <a class="header-anchor" href="#代码演示" aria-label="Permalink to &quot;代码演示&quot;">​</a></h2><p>只需要传一个 <code>开始方法</code> ，即可获得 对应的 <strong>loading</strong> 状态，以及 对应的 <strong>finish</strong> 方法。</p><p>单个控制，代码不超过 10 行</p>`);
  _push(ssrRenderComponent(_component_demo, { src: "components/useSend/demos/useSend-base.vue" }, null, _parent));
  _push(`<p>有了对状态的控制，我们可以很方便的，自定义一些按钮的加载状态</p>`);
  _push(ssrRenderComponent(_component_demo, { src: "components/useSend/demos/useSend-use.vue" }, null, _parent));
  _push(`<p>知道了 <code>useSend</code> 的基本用法后，既然有 <code>前端加载状态</code> 的控制，那一定少不了 <code>请求状态</code> 控制。接下来我们来介绍一下 工具类 <code>XRequest</code> 的简单用法。</p>`);
  _push(ssrRenderComponent(_component_demo, { src: "components/useSend/demos/XRequest-base.vue" }, null, _parent));
  _push(`<div class="warning custom-block"><p class="custom-block-title">📌 注意</p><p>这里我们为了让大家方便阅读文档，看到请求，简单的写了一个 node 服务。这个案例中，💩 请不要疯狂点击。会疯狂请求接口，请大家节制一点。💩 我们没做任何安全处理 🙉 因为不会</p><p>这也可以反向让大家知道更了解，工具类 <code>XRequest</code> 的用法，只对 <code>请求</code> 处理。</p></div>`);
  _push(ssrRenderComponent(_component_demo, { src: "components/useSend/demos/XRequest-use.vue" }, null, _parent));
  _push(`<p>下面介绍一下，<code>useSend</code> 和 <code>useSendStream</code> 相互结合的用法</p><p><strong>使用 <code>useSend</code> 对前端进行状态控制，使用 <code>useSendStream</code> 对后端进行状态控制</strong></p>`);
  _push(ssrRenderComponent(_component_demo, { src: "components/useSend/demos/useSend-XRequest.vue" }, null, _parent));
  _push(`<h2 id="配置参数-和-返回钩子" tabindex="-1">配置参数 和 返回钩子 <a class="header-anchor" href="#配置参数-和-返回钩子" aria-label="Permalink to &quot;配置参数 和 返回钩子&quot;">​</a></h2><h4 id="usesend" tabindex="-1">- <code>useSend</code> <a class="header-anchor" href="#usesend" aria-label="Permalink to &quot;- \`useSend\`&quot;">​</a></h4><ul><li><strong>参数</strong></li></ul><table tabindex="0"><thead><tr><th>参数名</th><th>说明</th><th>类型</th></tr></thead><tbody><tr><td>sendHandler</td><td>send 方法</td><td><code>() =&gt; void</code></td></tr><tr><td>abortHandler</td><td>abort 方法</td><td><code>() =&gt; void</code></td></tr></tbody></table><ul><li><strong>返回值</strong></li></ul><table tabindex="0"><thead><tr><th>属性名</th><th>说明</th><th>类型</th></tr></thead><tbody><tr><td>send</td><td>开始 加载状态 支持回调</td><td><code>() =&gt; void</code></td></tr><tr><td>abort</td><td>中断 加载状态 支持回调</td><td><code>() =&gt; void</code></td></tr><tr><td>loading</td><td>加载状态</td><td><code>boolean</code></td></tr><tr><td>finish</td><td>结束 加载状态</td><td><code>() =&gt; void</code></td></tr></tbody></table><h4 id="xrequest" tabindex="-1">- <code>XRequest</code> <a class="header-anchor" href="#xrequest" aria-label="Permalink to &quot;- \`XRequest\`&quot;">​</a></h4><ul><li><strong>参数</strong></li></ul><table tabindex="0"><thead><tr><th>配置参数名</th><th>说明</th><th>类型</th></tr></thead><tbody><tr><td>baseURL</td><td>基础请求地址</td><td><code>string</code></td></tr><tr><td>type</td><td>请求类型，默认 SSE</td><td><code>BaseSSEProps&lt;T = string&gt;.type?: SSEType | undefined</code></td></tr><tr><td>transformer</td><td>transformer 回调，在这里可以对数据做解析处理</td><td><code>(e: string) =&gt; string | undefined</code></td></tr><tr><td>onMessage</td><td>请求中的回调</td><td><code>(msg: string | undefined) =&gt; void</code></td></tr><tr><td>onError</td><td>请求报错的回调</td><td><code>(es: EventSource, e: Event) =&gt; void</code></td></tr><tr><td>onOpen</td><td>SSE Open 状态</td><td><code>SSEWithSSEProps.onOpen?: (() =&gt; void) | undefined</code></td></tr><tr><td>onAbort</td><td>请求被终止的回调</td><td><code>(messages: (string | undefined)[]) =&gt; void</code></td></tr><tr><td>onFinish</td><td>请求结束的回调</td><td><code>(data: (string | undefined)[]) =&gt; void</code></td></tr></tbody></table><ul><li><strong>返回值</strong></li></ul><table tabindex="0"><thead><tr><th>属性名</th><th>说明</th><th>类型</th></tr></thead><tbody><tr><td>send</td><td>开始请求接口</td><td><code>XRequest&lt;string | undefined&gt;.send(url: string, options?: EventSourceInit | BaseFetchOptions): Promise&lt;XRequest&lt;string | undefined&gt;&gt;</code></td></tr><tr><td>abort</td><td>中断请求</td><td><code>XRequest&lt;string | undefined&gt;.abort(): void</code></td></tr></tbody></table><h2 id="总结" tabindex="-1">总结 <a class="header-anchor" href="#总结" aria-label="Permalink to &quot;总结&quot;">​</a></h2><p><code>useSend</code> 可以让用户更方便在前端展示和控制， <strong>加载中</strong> 状态。是一种对 <code>loading</code> 状态的封装方案 接受 <code>发送回调</code> 和一个<code>中断回调</code> ，提供 <code>发送</code> ，<code>中断 loading 状态</code> ，<code>结束 loading 状态</code> ，返回 <code>loading</code> 状态。</p><p><code>XRequest</code> 是一个请求的封装，提供了更便捷的请求方式，接受一个 <code>请求配置</code> ，返回一个 <code>请求响应</code> 对象。</p></div>`);
}
const _sfc_setup = _sfc_main.setup;
_sfc_main.setup = (props, ctx) => {
  const ssrContext = useSSRContext();
  (ssrContext.modules || (ssrContext.modules = /* @__PURE__ */ new Set())).add("components/useSend/index.md");
  return _sfc_setup ? _sfc_setup(props, ctx) : void 0;
};
const index = /* @__PURE__ */ _export_sfc(_sfc_main, [["ssrRender", _sfc_ssrRender]]);
export {
  __pageData,
  index as default
};
